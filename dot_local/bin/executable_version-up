#!/usr/bin/env bash
# Copyright (C) 2017, Oleksandr Kucherenko
# Source: https://gist.github.com/OleksandrKucherenko/9fb14f81a29b46886ccd63b774c5959f
#
# Modified by Felix (shiftgeist) Hungenberg

function help(){
  echo 'usage: version-up [label]'
  echo ''
  echo 'labels:'
  echo '  major             version when you make incompatible API changes'
  echo '  minor             version when you add functionality in a backwards compatible manner'
  echo '  patch             version when you make backwards compatible bug fixes'
  echo ''
  echo 'other labels:'
  echo '  alpha             switch stage to alpha'
  echo '  beta              switch stage to beta'
  echo '  rc                switch stage to rc'
  exit 0
}

function latest_tag(){
  git describe --tags --abbrev=0 2>/dev/null
}

function latest_revision(){
  git rev-list --count HEAD 2>/dev/null
}

function version_dots(){
  echo "$TAG" | grep -o "\." | wc -l
}

function increment_patch(){
  PARTS[2]=$(( PARTS[2] + 1 ))
  PARTS[3]=0
}

function increment_minor(){
    PARTS[1]=$(( PARTS[1] + 1 ))
    PARTS[2]=0
    PARTS[3]=0
}

function incremet_major(){
  if [[ "${PARTS[0]}" == *"v"* ]]; then
    PARTS[0]=v$(( PARTS[0] + 1 ))
  else
    PARTS[0]=$(( PARTS[0] + 1 ))
  fi
  PARTS[1]=0
  PARTS[2]=0
  PARTS[3]=0
}

function compose(){
  MAJOR="${PARTS[0]}"
  MINOR=".${PARTS[1]}"
  PATCH=".${PARTS[2]}"
  REVISION=".${PARTS[3]}"
  SUFFIX="-${PARTS[4]}"

  [[ "${#PATCH}" == 1 ]] && PATCH=""
  [[ "${#REVISION}" == 1 ]] && REVISION=""
  [[ "${PARTS[3]}" == "0" ]] && REVISION=""

  # shrink patch and revision
  if [[ -z "${REVISION// }" ]]; then
    [[ "${PARTS[2]}" == "0" ]] && PATCH=".0"
  else # revision is not EMPTY
    [[ "${#PATCH}" == 0 ]] && PATCH=".0"
  fi

  # remove suffix if we don't have a alpha/beta/rc
  [[ "${#SUFFIX}" == 1 ]] && SUFFIX=""

  if [ "$DOTS" == "2" ]; then
    echo "${MAJOR}${MINOR}${PATCH}${REVISION}${SUFFIX}" # full format
  elif [ "$DOTS" == "1" ]; then
    echo "${MAJOR}${MINOR}${REVISION}${SUFFIX}" # full format
  fi
}

# do GIT data extracting
TAG=$(latest_tag)
REVISION=$(latest_revision)
DOTS=$(version_dots)

# {MAJOR}.{MINOR}[.{PATCH}[.{REVISION}][-(.*)]
#
#  Suffix: alpha, beta, rc
#    No Suffix --> {NEW_VERSION}-alpha
#    alpha --> beta
#    beta --> rc
#    rc --> {VERSION}
#
PARTS=( ${TAG//./ } )

# parse input parameters
for i in "$@"
do
  key="$i"

  case $key in
    alpha)
    PARTS[4]="alpha"
    ;;
    beta)
    PARTS[4]="beta"
    ;;
    rc)
    PARTS[4]="rc"
    ;;
    patch)
    increment_patch
    ;;
    minor)
    increment_minor
    ;;
    major)
    incremet_major
    ;;
    help|-h|--help)
    help
    ;;
  esac
  shift
done

# output
compose
