#!/usr/bin/env bash

__npm_set_tag() {
  if [ -f "package.json" ]; then
    jq ".version=\"$1\"" package.json >package.json.tmp
    mv package.json.tmp package.json
  fi
  __npm_command install
}

__npm_command() {
  if [[ -f bun.lockb ]]; then
    command bun "$@"
  elif [[ -f pnpm-lock.yaml ]]; then
    command pnpm "$@"
  elif [[ -f yarn.lock ]]; then
    command yarn "$@"
  else
    command npm "$@"
  fi
}

alias dev="__npm_command run dev"

# We wrap in a local function instead of exporting the variable directly in
# order to avoid interfering with manually-run git commands by the user.
__git() {
  GIT_OPTIONAL_LOCKS=0 command git "$@"
}

git_is_repo() {
  __git rev-parse HEAD >/dev/null 2>&1
}

gdesc() {
  __git describe --tags "$(__git rev-list --tags --max-count=1)"
}

# git flow hotfix start
gfh() {
  if [ "$#" -ne 0 ]; then
    NEW_GIT_TAG="$1"
  else
    NEW_GIT_TAG=$(up git patch)
  fi

  echo "Starting hotfix $NEW_GIT_TAG"

  if [ -z "$NEW_GIT_TAG" ]; then
    echo "No valid hotfix tag found after $(gdesc). Provide custom tag."
    return 1
  fi

  if __git checkout -b "hotfix/$NEW_GIT_TAG"; then
    if [ "$#" -eq 0 ]; then
      __npm_set_tag "$NEW_GIT_TAG"
    fi
  else
    return 1
  fi
}

# git flow release start
gfr() {
  if [ "$#" -ne 0 ]; then
    NEW_GIT_TAG="$1"
  else
    echo "$(gdesc) Â» [m]ajor, m[i]nor or [P]atch?"
    while read -r REPLY; do
      case $REPLY in
      m | major)
        NEW_GIT_TAG=$(up git major)
        ;;
      i | minor)
        NEW_GIT_TAG=$(up git minor)
        ;;
      *)
        NEW_GIT_TAG=$(up git patch)
        ;;
      esac
      break
    done
  fi

  echo "Starting release $NEW_GIT_TAG"

  if __git checkout -b "release/$NEW_GIT_TAG" develop; then
    __npm_set_tag "$NEW_GIT_TAG"
  else
    return 1
  fi
}

# git flow finish (any)
gff() {
  function_name=${0##*/}

  BRANCH=$(__git rev-parse --abbrev-ref HEAD)
  FLOW_TYPE="$(printf '%s' "$BRANCH" | cut -d '/' -f1)"
  FLOW_NAME="$(printf '%s' "$BRANCH" | cut -d '/' -f2)"

  echo "Finishing $FLOW_TYPE"

  export GIT_MERGE_AUTOEDIT=no

  case "$FLOW_TYPE" in
  feature)
    # nothing to do here, just don't run into catchall
    ;;
  hotfix | release)
    git checkout master
    git merge --no-ff "$FLOW_TYPE/$FLOW_NAME"
    git tag -a "$FLOW_NAME" -m "$FLOW_TYPE $FLOW_NAME"
    ;;
  *)
    printf "no valid type found %s" "$function_name"
    unset GIT_MERGE_AUTOEDIT
    exit 1
    ;;
  esac

  git checkout develop
  git merge --no-ff "$FLOW_TYPE/$FLOW_NAME"
  git branch -d "$FLOW_TYPE/$FLOW_NAME"

  unset GIT_MERGE_AUTOEDIT
}
