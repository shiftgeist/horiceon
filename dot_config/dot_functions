#!/bin/sh

__npm_set_tag() {
  if [ -f "package.json" ]; then
    jq ".version=\"$1\"" package.json >package.json.tmp
    mv package.json.tmp package.json
  fi
  __npm_install_lock_file
}

__npm_install_lock_file() {
  if [ -f "package-lock.json" ]; then
    npm install
  fi
  # if [ -f "pnpm-lock.yaml" ]; then
  #   pnpm install
  # fi
  if [ -f "yarn.lock" ]; then
    yarn install
  fi
}

# We wrap in a local function instead of exporting the variable directly in
# order to avoid interfering with manually-run git commands by the user.
__git() {
  GIT_OPTIONAL_LOCKS=0 command git "$@"
}

git_is_repo() {
  __git rev-parse HEAD >/dev/null 2>&1
}

__git_is_clean() {
  if __git status -s | read -r REPLY; then
    return 1
  else
    return 0
  fi
}

# Outputs the name of the current branch
git_current_branch() {
  git_is_repo || return
  ref=$(__git symbolic-ref --quiet HEAD 2>/dev/null)
  ret=$?
  if [ $ret -ne 0 ]; then
    [ $ret -eq 128 ] && return # no git repo.
    ref=$(__git rev-parse --short HEAD 2>/dev/null) || return
  fi
  echo "${ref#refs/heads/}"
}

# Outputs the id of the current commit
__git_current_commit() {
  ref=$(__git rev-list --tags --max-count=1)
  echo "$ref"
}

git_latest_tag() {
  __git describe --tags "$(__git_current_commit)"
}
alias gdesc="git_latest_tag"

gitflow_feature() {
  __git checkout -b "feature/$1" develop
}

gitflow_hotfix() {
  if [ "$#" -ne 0 ]; then
    NEW_GIT_TAG="$1"
  else
    NEW_GIT_TAG=$(up git patch)
  fi

  if [ -z "$NEW_GIT_TAG" ]; then
    echo "No valid hotfix tag found after $(git_latest_tag). Provide custom tag."
    return 1
  fi

  if __git checkout -b "hotfix/$NEW_GIT_TAG"; then
    if [ "$#" -eq 0 ]; then
      __npm_set_tag "$NEW_GIT_TAG"
    fi
  else
    return 1
  fi
}
alias gfh="gitflow_hotfix"

gitflow_release() {
  if [ "$#" -ne 0 ]; then
    NEW_GIT_TAG="$1"
  else
    echo "$(git_latest_tag) Â» [m]ajor, m[i]nor or [P]atch?"
    while read -r REPLY; do
      case $REPLY in
      m | major)
        NEW_GIT_TAG=$(up git major)
        ;;
      i | minor)
        NEW_GIT_TAG=$(up git minor)
        ;;
      *)
        NEW_GIT_TAG=$(up git patch)
        ;;
      esac
      break
    done
  fi

  if __git checkout -b "release/$NEW_GIT_TAG" develop; then
    __npm_set_tag "$NEW_GIT_TAG"
  else
    return 1
  fi
}
alias gfr="gitflow_release"

gitflow_finish() {
  function_name=${0##*/}

  BRANCH=$(git_current_branch)
  FLOW_TYPE="$(printf '%s' "$BRANCH" | cut -d '/' -f1)"
  FLOW_NAME="$(printf '%s' "$BRANCH" | cut -d '/' -f2)"

  export GIT_MERGE_AUTOEDIT=no

  echo "step 1"
  case "$FLOW_TYPE" in
  feature)
    echo "nothing to do here"
    ;;
  hotfix | release)
    git checkout master
    git merge --no-ff "$FLOW_TYPE/$FLOW_NAME"
    git tag -a "$FLOW_NAME" -m "$FLOW_TYPE $FLOW_NAME"
    ;;
  *)
    echo "no valid type found ($function_name)"
    unset GIT_MERGE_AUTOEDIT
    exit 1
    ;;
  esac

  echo "step 2"
  git checkout develop
  git merge --no-ff "$FLOW_TYPE/$FLOW_NAME"
  git branch -d "$FLOW_TYPE/$FLOW_NAME"

  unset GIT_MERGE_AUTOEDIT
}
alias gff="gitflow_finish"
