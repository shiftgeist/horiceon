#!/bin/sh

__npm_set_tag() {
  if [ -f "package.json" ]
  then
    jq ".version=\"$1\"" package.json > package.json.tmp
    mv package.json.tmp package.json
  fi
  if [ -f "package-lock.json" ]
  then
    npm install
  fi
}

__npm_manager() {
  if [ -f "pnpm-lock.yaml" ]
  then
    command pnpm "$@"
  elif [ -f "yarn.lock" ]
  then
    command yarn "$@"
  else
    command npm "$@"
  fi
}

# We wrap in a local function instead of exporting the variable directly in
# order to avoid interfering with manually-run git commands by the user.
__git() {
  GIT_OPTIONAL_LOCKS=0 command git "$@"
}

git_is_repo() {
  __git rev-parse HEAD > /dev/null 2>&1
}

git_is_clean() {
  if __git status -s | read -r REPLY
  then
    return 1
  else
    return 0
  fi
}

# Check if main exists and use instead of master
git_main_branch() {
  command git rev-parse --git-dir >/dev/null || return

  for branch in main trunk; do
    if command git show-ref -q --verify refs/heads/$branch
    then
      echo $branch
      return
    fi
  done
  echo master
}

__git_checkout_main() {
  git checkout "$(git_main_branch)"
}

# Outputs the name of the current branch
__git_current_branch() {
  git_is_repo || return
  ref=$(__git symbolic-ref --quiet HEAD 2> /dev/null)
  ret=$?
  if [ $ret -ne 0 ]
  then
    [ $ret -eq 128 ] && return  # no git repo.
    ref=$(__git rev-parse --short HEAD 2> /dev/null) || return
  fi
  echo "${ref#refs/heads/}"
}

# Outputs the id of the current commit
__git_current_commit() {
  ref=$(__git rev-list --tags --max-count=1)
  echo "$ref"
}

__git_fzf_branch() {
  git_is_repo || return

  __git branch --all --sort=-committerdate --color=always |
    # remove entries with "HEAD" in them
    grep -v HEAD |
    # run thought fzf
    fzf --ansi --no-multi --preview-window right:65% --preview 'git log -n 50 --color=always --date=short --pretty="format:%C(auto)%cd %h%d %s (%an)" $(sed "s/.* //" <<< {})' |
    # trim asterisk and leading whitespace
    sed "s/.* //"
}

__git_fzf() (
  # arg 1: method
  # arg 2: branch

  git_is_repo || return

  git_method=$1

  # has argument
  if [ "$#" -gt 1 ]
  then
    eval "__git $*"
    exit $?
  fi

  branch=$(__git_fzf_branch)
  [ "$branch" = "" ] && return

  case $branch in
    remotes/*)
      eval "__git $git_method $(echo "$branch" | cut -d '/' -f 3-4)";
    ;;
    *)
      eval "__git $git_method $branch";
    ;;
  esac
)

__git_push_current_to_origin() {
  __git push --set-upstream origin "$(__git_current_branch)"
}

__git_reset_current() {
  __git reset origin/"$(__git_current_branch)" --hard
}

__git_latest_tag() {
  __git describe --tags "$(__git_current_commit)"
}

__git_push_force_ask() {
  read -r "REPLY?Force push? (Yy) "
  while read -r REPLY
  do
    case $REPLY in
      *)
        __git push --force-with-lease
      ;;
    esac
  done
}

__git_flow_release_start() {
  if [ "$#" -ne 0 ]
  then
    NEW_GIT_TAG="$1"
  else
    echo "$(__git_latest_tag) Â» [m]ajor, m[I]nor or [p]atch?"
    while read -r REPLY
    do
      case $REPLY in
        m|major)
          NEW_GIT_TAG=$(up git major)
        ;;
        p|patch)
          NEW_GIT_TAG=$(up git patch)
        ;;
        *)
          NEW_GIT_TAG=$(up git minor)
        ;;
      esac

      break
    done
  fi

  __git flow release start "$NEW_GIT_TAG"

  if [ "$#" -eq 0 ]
  then
    __npm_set_tag "$NEW_GIT_TAG"
  fi
}

__git_flow_hotfix_start() {
  if [ "$#" -ne 0 ]
  then
    NEW_GIT_TAG="$1"
  else
    NEW_GIT_TAG=$(up git patch)
  fi

  __git flow hotfix start "$NEW_GIT_TAG"

  if [ "$#" -eq 0 ]
  then
    __npm_set_tag "$NEW_GIT_TAG"
  fi
}

__git_flow_finish() {
  BRANCH=$(__git_current_branch)
  FLOW_TYPE="$(printf '%s' "$BRANCH" | cut -d '/' -f1)"
  FLOW_NAME="$(printf '%s' "$BRANCH" | cut -d '/' -f2)"

  export GIT_MERGE_AUTOEDIT=no
  __git flow "$FLOW_TYPE" finish --message "$FLOW_NAME" --showcommands
  unset GIT_MERGE_AUTOEDIT
}
